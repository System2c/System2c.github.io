<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>多边形的直径求法</title>
      <link href="/2023/01/05/%E7%A0%81%E9%A2%98%E9%9B%86/%E5%87%B8%E5%A4%9A%E8%BE%B9%E5%BD%A2%E7%9A%84%E7%9B%B4%E5%BE%84/"/>
      <url>/2023/01/05/%E7%A0%81%E9%A2%98%E9%9B%86/%E5%87%B8%E5%A4%9A%E8%BE%B9%E5%BD%A2%E7%9A%84%E7%9B%B4%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<p><strong>参考</strong><br><strong>·<a href="https://article.itxueyuan.com/RdR53m">https://article.itxueyuan.com/RdR53m</a></strong><br><strong>·<a href="https://blog.csdn.net/lemonxiaoxiao/article/details/108619552">https://blog.csdn.net/lemonxiaoxiao/article/details/108619552</a></strong><br><strong>·<a href="https://www.cnblogs.com/HolyChen/p/5982184.html">https://www.cnblogs.com/HolyChen/p/5982184.html</a></strong><br><strong>·<a href="https://oi-wiki.org/geometry/rotating-calipers/">https://oi-wiki.org/geometry/rotating-calipers/</a></strong></p><h2 id="问题引入">问题引入</h2><p>给定一个多边形S，寻找该多边形直径，即寻找它们之间有<strong>最大距离的一对点</strong>。</p><h2 id="前置知识">前置知识</h2><h3 id="凸包">凸包</h3><p>假设平面上有p0~p12共13个点，过某些点作一个多边形，使这个多边形能把所有点都“包”起来。当这个多边形是凸多边形的时候，我们就叫它“凸包”。</p><p><img src="https://s2.loli.net/2023/01/05/bCvslEM83ijqfSm.png" alt=""></p><h3 id="支撑线">支撑线</h3><p>直线 (L) 过凸多边形 (P) 一个顶点，使 (P) 全在 (L) 一侧，此时称直线 (L) 为凸多边形 (P) 的支撑线。</p><p><img src="https://s2.loli.net/2023/01/05/YlcbZNgivU9Rh5S.png#pic_center" alt=""></p><h3 id="对踵点">对踵点</h3><p>两条平行直线过凸多边形的两个顶点且将凸多边形夹在其之间，此时这对顶点称作对踵点。</p><p><img src="https://s2.loli.net/2023/01/05/ZS2L8Yxen9jGRFz.png#pic_center" alt=""></p><p>两条平行支撑线所过两点是一对对踵点。</p><h3 id="凸多边形直径定理">凸多边形直径定理</h3><p>凸多边形 (P) 的直径 (=) 凸多边形 (P) 的所有平行支撑线之间距离的最大值。<br>凸多边形的直径可在对踵点对中寻找。</p><h2 id="算法描述">算法描述</h2><h3 id="Graham-Scan法">Graham Scan法</h3><p><strong>用以寻找凸包。</strong></p><p>它的时间复杂度与所采用的排序算法时间复杂度相同，通常采用线性对数算法，因此为 $O(Nlog(N))$ 。</p><ol><li>找到所有点$P_{0,1,…,N−1}$中<strong>最下方的点</strong>，记为$P_L$；</li><li>计算所有其他的点$P_i(i≠L)$与 $P_L$构成的向量$\overrightarrow{P_LP_i}$相对于水平轴的夹角。因为所有的点都在该$P_L$上方，因此向量的取值范围为(0,180) ，所以可以用余切值代替角度值；</li><li>对所有其他的点按照第2步算出的角度进行排序，且$P_L$为排序后的数组的第0位；</li><li>从点$P_L$开始，依此连接每一个点（已经排序过），每连接一个点检测连线的走向是否是逆时针的，如果是则留下该点的前一个点，反之去除前一个点，使之与前面第二个点直接连接，继续这一检测，直到是逆时针或者所有点都被检测过为止。</li></ol><p>判断三个点依此连成两条线段走向是否为逆时针，用这两条线段向量的叉积(即叉乘)判断：叉积&gt;0，逆时针；反之顺时针或者共线。<br><img src="https://s2.loli.net/2023/01/05/7mjuaSJhGvAewOL.png" alt=""></p><p>附上部分代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="comment">#a为存放点集的列表</span></span><br><span class="line">a = []</span><br><span class="line"><span class="comment">#l为直径</span></span><br><span class="line">l = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    m = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">float</span>,<span class="built_in">input</span>().split()))</span><br><span class="line">    a.append(m)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;----------开始寻找凸包-------------&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1.找所有点中最下方的点PL</span></span><br><span class="line"><span class="comment">#对纵坐标排序，a[0]即为点集P中最下方的点PL</span></span><br><span class="line">a = <span class="built_in">sorted</span>(a,key = <span class="keyword">lambda</span> x:x[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment">#与PL在一条水平轴上的向量坐标</span></span><br><span class="line">x1,y1 = <span class="number">1</span>,a[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.求其它点与PL构成的向量PLPi与水平轴的夹角的余弦值</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)):</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">        a[i].append(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        x2,y2 = a[i][<span class="number">0</span>]-a[<span class="number">0</span>][<span class="number">0</span>],a[i][<span class="number">1</span>]-a[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">        cosx = (x2+y2*y1) / (sqrt(x1**<span class="number">2</span>+y1**<span class="number">2</span>)*sqrt(x2**<span class="number">2</span>+y2**<span class="number">2</span>))</span><br><span class="line">        a[i].append(cosx)</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.按0到180的角度排序</span></span><br><span class="line">a[<span class="number">1</span>:] = <span class="built_in">sorted</span>(a[<span class="number">1</span>:],key = <span class="keyword">lambda</span> x:(-x[<span class="number">2</span>]))</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.检测是否为凸包上的点</span></span><br><span class="line">i = <span class="number">2</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="built_in">len</span>(a): </span><br><span class="line">    x1,y1 = a[i-<span class="number">1</span>][<span class="number">0</span>]-a[i-<span class="number">2</span>][<span class="number">0</span>],a[i-<span class="number">1</span>][<span class="number">1</span>]-a[i-<span class="number">2</span>][<span class="number">1</span>]</span><br><span class="line">    x2,y2 = a[i][<span class="number">0</span>]-a[i-<span class="number">1</span>][<span class="number">0</span>],a[i][<span class="number">1</span>]-a[i-<span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> (x1*y2)-(x2*y1) &gt; <span class="number">0</span>:</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment">#删去前一个元素</span></span><br><span class="line">        <span class="keyword">del</span> a[i-<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment">#此时a中的点全为凸包上的点</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="旋转卡壳法">旋转卡壳法</h3><p><strong>寻找凸多边形对踵点的算法。</strong></p><p>主要思路：利用凸包单调性，枚举点 -&gt; 更新点对 -&gt; 更新答案。</p><ol><li>求出凸多边形凸包。此时最远点对必在凸包上，时间复杂度为 $O(Nlog(N))$ 。</li><li>找到一对初始对踵点，作水平切线。<br>选 $y_{max}$ 与 $y_{min}$。<br>更新答案。</li><li>沿一个方向旋转这两条切线，直到其中一条与凸包的边重叠。<br>产生新对踵点对，更新答案。<br>不断重复这一过程，直到所有点对都已生成对踵点。</li></ol><p>该算法本质上是对于每一条凸包的边，计算最远的过凸包上点的平行直线。<br>两直线距离可看作三角形面积除以底边，用叉积计算。</p><p><strong>注意：</strong> 求出凸包后的数组自然地是按照逆时针旋转的顺序排列，不过要记得提前将最左下角的 $i$ 节点补到数组最后，这样在挨个枚举边$(i,i+1)$时，才能把所有边都枚举到。</p><p><img src="https://s2.loli.net/2023/01/06/TGwVyXbNavjis3W.png" alt=""><br>枚举过程中，对于每条边，都检查 $j+1$ 到边$(i,i+1)$的距离是不是比 $i$ 更大，如果是就将 $j$ 加一，否则说明 $j$ 是此边的最优点。判断点到边的距离大小时可以用叉积分别算出两个三角形的面积（如图，黄、蓝两个同底三角形的面积）并直接比较。</p><p><strong>例题：</strong><br>来源：码题集 <a href="https://matiji.net/exam/brushquestion/373/3846/4C6668FEB8CFD6520DE73B365B31D1A4">https://matiji.net/exam/brushquestion/373/3846/4C6668FEB8CFD6520DE73B365B31D1A4</a></p><p><img src="https://s2.loli.net/2023/01/06/GDicXJyh4raKmW1.png" alt=""></p><p>附上代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sqr</span>(<span class="params">i, j, a</span>):</span><br><span class="line">    x1 = a[i][<span class="number">0</span>] - a[i-<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">    y1 = a[i][<span class="number">1</span>] - a[i-<span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line">    x2 = a[j][<span class="number">0</span>] - a[i-<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">    y2 = a[j][<span class="number">1</span>] - a[i-<span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(x1*y2-x2*y1)</span><br><span class="line"></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="comment">#a为存放点集的列表</span></span><br><span class="line">a = []</span><br><span class="line"><span class="comment">#l为直径</span></span><br><span class="line">l = <span class="number">0</span></span><br><span class="line">temp = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    m = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">float</span>,<span class="built_in">input</span>().split()))</span><br><span class="line">    a.append(m)</span><br><span class="line">a.append(a[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#找初始对踵点</span></span><br><span class="line">xymax = <span class="built_in">max</span>(a,key= <span class="keyword">lambda</span> x:x[<span class="number">1</span>])</span><br><span class="line">ymax = xymax[<span class="number">1</span>]</span><br><span class="line">xymin = <span class="built_in">min</span>(a,key= <span class="keyword">lambda</span> x:x[<span class="number">1</span>])</span><br><span class="line">ymin = xymin[<span class="number">1</span>]</span><br><span class="line"><span class="comment">#更新答案</span></span><br><span class="line">l = ymax - ymin</span><br><span class="line"><span class="comment">#旋转线</span></span><br><span class="line">j = <span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">    x1 = a[i][<span class="number">0</span>] - a[i-<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">    y1 = a[i][<span class="number">1</span>] - a[i-<span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">while</span> sqr(i,j,a) &lt;= sqr(i,j % n + <span class="number">1</span>,a):</span><br><span class="line">        j = j % n + <span class="number">1</span></span><br><span class="line">    x2 = a[j][<span class="number">0</span>] - a[i-<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">    y2 = a[j][<span class="number">1</span>] - a[i-<span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line">    x3 = a[j][<span class="number">0</span>] - a[i][<span class="number">0</span>]</span><br><span class="line">    y3 = a[j][<span class="number">1</span>] - a[i][<span class="number">1</span>]</span><br><span class="line">    l1 = <span class="built_in">max</span>(sqrt(x2**<span class="number">2</span>+y2**<span class="number">2</span>),sqrt(x3**<span class="number">2</span>+y3**<span class="number">2</span>))</span><br><span class="line">    l = <span class="built_in">max</span>(l,l1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;:.6f&#125;&quot;</span>.<span class="built_in">format</span>(l))</span><br></pre></td></tr></table></figure><p>OvO</p>]]></content>
      
      
      <categories>
          
          <category> 码题集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 码题集作业 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2023/01/02/test/"/>
      <url>/2023/01/02/test/</url>
      
        <content type="html"><![CDATA[<h2 id="二级标题">二级标题</h2><h3 id="333">333</h3><p>啦啦啦，小兔子真好看</p><h3 id="333-2">333</h3><p>哇真的是你呀哈哈哎哟</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/09/24/hello-world/"/>
      <url>/2022/09/24/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
